test -z "$PROFILEREAD" && test -z "$PROFILEONCE" &&
    { PROFILEONCE=true ; . /etc/profile ; }

# early WSL detection
# 5.10.16.3-microsoft-standard-WSL2
if [[ $(uname -r) =~ "WSL2" ]] ; then
    # Auto-detect DISPLAY by taking IP address from "DHCP" config
    if [[ $DISPLAY = "" ]] ; then
        # export WINDOWS_HOST=$(cat /etc/resolv.conf | grep nameserver | cut -d ' ' -f 2)
        export WINDOWS_HOST=$(ip route show default|grep "default via"|cut -d ' ' -f 3)
        export DISPLAY=$WINDOWS_HOST:0
    fi
    domain="$(hostname -d)"
    if [[ "$domain" ]] ; then
        if ! grep $domain /etc/resolv.conf 2>/dev/null ; then
            echo "search $domain" | sudo tee -a /etc/resolv.conf >/dev/null
        fi
    fi
fi

# Source helpers
test -e ~/.alias_all && . ~/.alias_all
test -e ~/.alias && . ~/.alias
test -e ~/.git-completion.bash && . ~/.git-completion.bash
test -e ~/.ct-completion.bash && . ~/.ct-completion.bash
test -e ~/.vboxmanage-completion.bash && . ~/.vboxmanage-completion.bash
test -e ~/.cargo/env && . ~/.cargo/env

# standard environment
test -z "${LESS/*-R*/}" || export LESS="$LESS -R"
test -z "${LS_OPTIONS}" && export LS_OPTIONS='--color=auto'

export EDITOR="vim -X"
export CVS_RSH="`type -p ssh`"
export RSYNC_RSH="`type -p ssh`"
export PATH=~/bin:$PATH:/home/pub/bin
export PERL5LIB=~/usr/lib/perl5:~/usr/lib/perl5/site_perl
export LD_LIBRARY_PATH=~/usr/lib
export MANPATH=~/usr/share/man:$MANPATH

if [ -d ~/opt/jdk1.8.0_171/ ] ; then
    export JAVA_HOME=~/opt/jdk1.8.0_171
    export PATH=~/bin:~/opt/jdk1.8.0_171/bin:$PATH:/home/pub/bin
elif [ -d ~/opt/jdk1.7.0_71 ] ; then
    export JAVA_HOME=~/opt/jdk1.7.0_71
    export PATH=~/bin:~/opt/jdk1.7.0_71/bin:$PATH:/home/pub/bin
fi

# see ~/.git-completion.bash
GIT_PS1_SHOWDIRTYSTATE=1            # "*" when dirty
GIT_PS1_SHOWSTASHSTATE=1            # "$" when stashed
#GIT_PS1_SHOWUNTRACKEDFILES=1       # "%" untracked files
GIT_PS1_SHOWUPSTREAM="auto verbose" # also: legacy, git, svn

# standard Prompt
test -z "$PS1_org" && export PS1_org="$PS1"
PS1_mono='\u@\h:\w$(__git_ps1 " (%s)") $ '
PS1=$PS1_mono


# color version. On older bash versions (3.x?) this fails with multi-line
# editing, so either should have \n after last escape sequence or simply
# don't use it. bash-4.1.5(1) works (bash-3.2.33(1) doesn't).
PS1_color='\[\e]0;\w\a\]\[\e[32m\]\u@\h:\[\e[33m\]\w\[\e[32m\]$(__git_ps1 " (%s)")\[\e[0m\] $ '
PS1_color_n='\[\e]0;\w\a\]\[\e[32m\]\u@\h:\[\e[33m\]\w\[\e[32m\]$(__git_ps1 " (%s)")\[\e[0m\]\n$ '

if [ -f /.dockerenv ] ; then
    PS1_color='\[\e]0;\w\a\]\[\e[32m\]\u@\[\e[31m\]DOCKER:\h:\[\e[33m\]\w\[\e[32m\]$(__git_ps1 " (%s)")\[\e[0m\] $ '
fi

# =~ is regex and excepts xterm-256color etc.
if [[ "$TERM" =~ "xterm" || "$TERM" = "rxvt-cygwin-native" ]] ; then
    [ "${BASH_VERSINFO[0]}" -ge "4" ] && PS1=$PS1_color
    # comment out next line to get monochrome propmt on bash-3.
    [ "${BASH_VERSINFO[0]}" -le "3" ] && PS1=$PS1_color_n
fi


# commands common to all logins
if ! [ $TERM ] ; then
    eval `tset -s -Q`
    case $TERM in
      con*|vt100) tset -Q -e ^?
        ;;
    esac
fi

# don't put duplicate lines or lines starting with space in the history.
# See bash(1) for more options
HISTCONTROL=ignoreboth

# append to the history file, don't overwrite it
shopt -s histappend

# Make multi-line commandsline in history
shopt -q -s cmdhist

# for setting history length see HISTSIZE and HISTFILESIZE in bash(1)
HISTSIZE=10000
HISTFILESIZE=20000
HISTTIMEFORMAT="[%F %T] "

# auto pager (avoid plain "history" kills $HISTSIZE lines of terminal history)
function history()
{
  if [ "$@" ] ; then
    command history "$@"
  else
    command history | less
  fi
}

# check the window size after each command and, if necessary,
# update the values of LINES and COLUMNS.
shopt -s checkwinsize

# Turn on the extended pattern matching features
# shopt -q -s extglob

# Safety: when there is no GIT, don't use it in prompt
if [ ! -x "`type -p git`" ] ; then
    __git_ps1() { fmt=$1 || "%s" ; printf $fmt "no git"; }
fi
# in MSYS, shell moans about non-implemented pipe subst or so
if [ "$MSYSTEM" = "MINGW32" ] ; then
    __git_ps1() { fmt=$1 || "%s" ; printf $fmt "[MSYS]"; }
    test -n "$PS1_org" && export PS1=$PS1_org
fi

# Old GIT versions (<=1.7.x?) do not support rev-list --count, set legacy mode.
if ! git rev-list --count HEAD >/dev/null 2>&1 ; then
    GIT_PS1_SHOWUPSTREAM="$GIT_PS1_SHOWUPSTREAM legacy"
fi

# enable color support of ls and also add handy aliases
if [ -x /usr/bin/dircolors ]; then
    test -r ~/.dircolors && eval "$(dircolors -b ~/.dircolors)" || eval "$(dircolors -b)"
    alias ls='ls --color=auto'
    #alias dir='dir --color=auto'
    #alias vdir='vdir --color=auto'

    alias grep='grep --color=auto'
    alias fgrep='fgrep --color=auto'
    alias egrep='egrep --color=auto'
fi

# some more ls aliases
alias l='ls -alF'

# Bash 5.1 - bracketed-paste now on by default, so let's disable it:
[[ ${SHELLOPTS} =~ (vi|emacs) ]] && bind 'set enable-bracketed-paste off'

umask 002

